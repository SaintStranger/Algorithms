#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <limits.h>


//1. Реализовать простейшую хеш-функцию. На вход функции подается строка, на выходе сумма кодов символов.
unsigned long long getHash(const char* str)
{
	const int p = 53;
	unsigned long long hash = 0, p_pow = 1;
	for (size_t i = 0; i < strlen(str); i++)
	{
		hash += (str[i] - 'a' + 1) * p_pow;
		p_pow *= p;
	}
	return hash;
};

int main()
{
	
	char str[SHRT_MAX];
	printf("enter a string \n");
	scanf("%s", str);

	printf("hash value: %llu", getHash(str));

    return 0;
};



//2. Переписать программу, реализующую двоичное дерево поиска.
#define T char

typedef struct tagNode * pNode;

typedef struct tagNode {
	T data;
	pNode left;
	pNode right;
	pNode parent;
} Node;

// Распечатка двоичного дерева
void printTree(pNode root) {
	if (root)
	{
		printf("%d", root->data);
		if (root->left || root->right)
		{
			printf("(");
			if (root->left)
				printTree(root->left);
			else
				printf("NULL");
			printf(",");
			if (root->right)
				printTree(root->right);
			else
				printf("NULL");
			printf(")");
		}
	}
};


pNode getFreeNode(T value, pNode parent) {
	pNode tmp = (pNode)malloc(sizeof(Node));
	tmp->left = tmp->right = NULL;
	tmp->data = value;
	tmp->parent = parent;
	return tmp;
};


void insert(pNode *head, int value) {
	pNode tmp = NULL;
	if (*head == NULL)
	{
		*head = getFreeNode(value, NULL);
		return;
	}
	tmp = *head;
	while (tmp)
	{
		if (value > tmp->data)
		{
			if (tmp->right)
			{
				tmp = tmp->right;
				continue;
			}
			else
			{
				tmp->right = getFreeNode(value, tmp);
				return;
			}
		}
		else if (value < tmp->data)
		{
			if (tmp->left)
			{
				tmp = tmp->left;
				continue;
			}
			else
			{
				tmp->left = getFreeNode(value, tmp);
				return;
			}
		}
		else
		{
			exit(2);
		}
	}
};

// Обход в прямом порядке
void preOrderTravers(pNode root) {
	if (root) {
		printf("%d ", root->data);
		preOrderTravers(root->left);
		preOrderTravers(root->right);
	}
};

// Симметричный обход
void inOrderTravers(pNode root) {
	if (root) {
		inOrderTravers(root->left);
		printf("%d ", root->data);
		inOrderTravers(root->right);
	}
};

// Обход в обратном порядке
void postOrderTravers(pNode root) {
	if (root) {
		postOrderTravers(root->left);
		postOrderTravers(root->right);
		printf("%d ", root->data);
	}
};


pNode search(pNode x, T value)
{
	if ((x == NULL) || (value == x->data))
		return x;
	if (value < x->data)
		return search(x->left, value);
	else
		return search(x->right, value);
};


int main()
{

	int isExit = 0;
	Node * Tree = NULL;

    int Ant;
    int treeArray[10] = {45, 2, 36, 17, 5, 99, 7, 8, 23, 10};

		int count = sizeof(treeArray)/sizeof(treeArray[0]);
		
		int i;
		for (i = 0; i < count; i++)
		{
			int value;
			value = treeArray[i];
			insert(&Tree, value);
		}

		printf("The tree is \n");
		printTree(Tree);
		int mode = 0;
		printf("\nWhich way to travere");
		printf("\n(1-PreOrder, 2-InOrder, 3-PostOrder):");
		scanf("%d", &mode);
		if (mode < 1 && mode > 3)
			mode = 1;

		switch (mode)
		{
		case 1:
			printf("\nPreOrderTraverse:");
			preOrderTravers(Tree);
			break;
		case 2:
			printf("\nInOrderTraverse:");
			inOrderTravers(Tree);
			break;
		case 3:
			printf("\nPostOrderTraverse:");
			postOrderTravers(Tree);
			break;
		default:
			break;
		}

		pNode node = search(Tree, 6);

	return 0;
};
